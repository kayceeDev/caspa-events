// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/kayceeDev/caspa-events/ent-go/ent/event"
	"github.com/kayceeDev/caspa-events/ent-go/ent/location"
	"github.com/kayceeDev/caspa-events/ent-go/ent/predicate"
	"github.com/kayceeDev/caspa-events/ent-go/ent/ticket"
	"github.com/kayceeDev/caspa-events/ent-go/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeEvent    = "Event"
	TypeLocation = "Location"
	TypeTicket   = "Ticket"
	TypeUser     = "User"
)

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	uuid                  *uuid.UUID
	title                 *string
	description           *string
	start_date            *time.Time
	end_date              *time.Time
	event_type            *string
	status                *event.Status
	is_public             *bool
	is_paid               *bool
	max_participants      *int
	addmax_participants   *int
	registration_deadline *time.Time
	cover_photo_id        *string
	clearedFields         map[string]struct{}
	user                  *int
	cleareduser           bool
	location              *int
	clearedlocation       bool
	guest                 map[int]struct{}
	removedguest          map[int]struct{}
	clearedguest          bool
	ticket                map[int]struct{}
	removedticket         map[int]struct{}
	clearedticket         bool
	done                  bool
	oldValue              func(context.Context) (*Event, error)
	predicates            []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EventMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EventMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EventMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EventMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EventMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EventMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUUID sets the "uuid" field.
func (m *EventMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *EventMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *EventMutation) ResetUUID() {
	m.uuid = nil
}

// SetTitle sets the "title" field.
func (m *EventMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EventMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EventMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
}

// SetStartDate sets the "start_date" field.
func (m *EventMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EventMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EventMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *EventMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EventMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EventMutation) ResetEndDate() {
	m.end_date = nil
}

// SetEventType sets the "event_type" field.
func (m *EventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *EventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *EventMutation) ResetEventType() {
	m.event_type = nil
}

// SetStatus sets the "status" field.
func (m *EventMutation) SetStatus(e event.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EventMutation) Status() (r event.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldStatus(ctx context.Context) (v event.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EventMutation) ResetStatus() {
	m.status = nil
}

// SetIsPublic sets the "is_public" field.
func (m *EventMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *EventMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *EventMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetIsPaid sets the "is_paid" field.
func (m *EventMutation) SetIsPaid(b bool) {
	m.is_paid = &b
}

// IsPaid returns the value of the "is_paid" field in the mutation.
func (m *EventMutation) IsPaid() (r bool, exists bool) {
	v := m.is_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPaid returns the old "is_paid" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldIsPaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPaid: %w", err)
	}
	return oldValue.IsPaid, nil
}

// ResetIsPaid resets all changes to the "is_paid" field.
func (m *EventMutation) ResetIsPaid() {
	m.is_paid = nil
}

// SetMaxParticipants sets the "max_participants" field.
func (m *EventMutation) SetMaxParticipants(i int) {
	m.max_participants = &i
	m.addmax_participants = nil
}

// MaxParticipants returns the value of the "max_participants" field in the mutation.
func (m *EventMutation) MaxParticipants() (r int, exists bool) {
	v := m.max_participants
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxParticipants returns the old "max_participants" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMaxParticipants(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxParticipants is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxParticipants requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxParticipants: %w", err)
	}
	return oldValue.MaxParticipants, nil
}

// AddMaxParticipants adds i to the "max_participants" field.
func (m *EventMutation) AddMaxParticipants(i int) {
	if m.addmax_participants != nil {
		*m.addmax_participants += i
	} else {
		m.addmax_participants = &i
	}
}

// AddedMaxParticipants returns the value that was added to the "max_participants" field in this mutation.
func (m *EventMutation) AddedMaxParticipants() (r int, exists bool) {
	v := m.addmax_participants
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxParticipants resets all changes to the "max_participants" field.
func (m *EventMutation) ResetMaxParticipants() {
	m.max_participants = nil
	m.addmax_participants = nil
}

// SetRegistrationDeadline sets the "registration_deadline" field.
func (m *EventMutation) SetRegistrationDeadline(t time.Time) {
	m.registration_deadline = &t
}

// RegistrationDeadline returns the value of the "registration_deadline" field in the mutation.
func (m *EventMutation) RegistrationDeadline() (r time.Time, exists bool) {
	v := m.registration_deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationDeadline returns the old "registration_deadline" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRegistrationDeadline(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationDeadline: %w", err)
	}
	return oldValue.RegistrationDeadline, nil
}

// ClearRegistrationDeadline clears the value of the "registration_deadline" field.
func (m *EventMutation) ClearRegistrationDeadline() {
	m.registration_deadline = nil
	m.clearedFields[event.FieldRegistrationDeadline] = struct{}{}
}

// RegistrationDeadlineCleared returns if the "registration_deadline" field was cleared in this mutation.
func (m *EventMutation) RegistrationDeadlineCleared() bool {
	_, ok := m.clearedFields[event.FieldRegistrationDeadline]
	return ok
}

// ResetRegistrationDeadline resets all changes to the "registration_deadline" field.
func (m *EventMutation) ResetRegistrationDeadline() {
	m.registration_deadline = nil
	delete(m.clearedFields, event.FieldRegistrationDeadline)
}

// SetCoverPhotoID sets the "cover_photo_id" field.
func (m *EventMutation) SetCoverPhotoID(s string) {
	m.cover_photo_id = &s
}

// CoverPhotoID returns the value of the "cover_photo_id" field in the mutation.
func (m *EventMutation) CoverPhotoID() (r string, exists bool) {
	v := m.cover_photo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverPhotoID returns the old "cover_photo_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCoverPhotoID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverPhotoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverPhotoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverPhotoID: %w", err)
	}
	return oldValue.CoverPhotoID, nil
}

// ClearCoverPhotoID clears the value of the "cover_photo_id" field.
func (m *EventMutation) ClearCoverPhotoID() {
	m.cover_photo_id = nil
	m.clearedFields[event.FieldCoverPhotoID] = struct{}{}
}

// CoverPhotoIDCleared returns if the "cover_photo_id" field was cleared in this mutation.
func (m *EventMutation) CoverPhotoIDCleared() bool {
	_, ok := m.clearedFields[event.FieldCoverPhotoID]
	return ok
}

// ResetCoverPhotoID resets all changes to the "cover_photo_id" field.
func (m *EventMutation) ResetCoverPhotoID() {
	m.cover_photo_id = nil
	delete(m.clearedFields, event.FieldCoverPhotoID)
}

// SetOrganizerID sets the "organizer_id" field.
func (m *EventMutation) SetOrganizerID(i int) {
	m.user = &i
}

// OrganizerID returns the value of the "organizer_id" field in the mutation.
func (m *EventMutation) OrganizerID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizerID returns the old "organizer_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldOrganizerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizerID: %w", err)
	}
	return oldValue.OrganizerID, nil
}

// ResetOrganizerID resets all changes to the "organizer_id" field.
func (m *EventMutation) ResetOrganizerID() {
	m.user = nil
}

// SetLocationID sets the "location_id" field.
func (m *EventMutation) SetLocationID(i int) {
	m.location = &i
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *EventMutation) LocationID() (r int, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLocationID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *EventMutation) ClearLocationID() {
	m.location = nil
	m.clearedFields[event.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *EventMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[event.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *EventMutation) ResetLocationID() {
	m.location = nil
	delete(m.clearedFields, event.FieldLocationID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EventMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EventMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[event.FieldOrganizerID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EventMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EventMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EventMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EventMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *EventMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[event.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *EventMutation) LocationCleared() bool {
	return m.LocationIDCleared() || m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *EventMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *EventMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// AddGuestIDs adds the "guest" edge to the User entity by ids.
func (m *EventMutation) AddGuestIDs(ids ...int) {
	if m.guest == nil {
		m.guest = make(map[int]struct{})
	}
	for i := range ids {
		m.guest[ids[i]] = struct{}{}
	}
}

// ClearGuest clears the "guest" edge to the User entity.
func (m *EventMutation) ClearGuest() {
	m.clearedguest = true
}

// GuestCleared reports if the "guest" edge to the User entity was cleared.
func (m *EventMutation) GuestCleared() bool {
	return m.clearedguest
}

// RemoveGuestIDs removes the "guest" edge to the User entity by IDs.
func (m *EventMutation) RemoveGuestIDs(ids ...int) {
	if m.removedguest == nil {
		m.removedguest = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.guest, ids[i])
		m.removedguest[ids[i]] = struct{}{}
	}
}

// RemovedGuest returns the removed IDs of the "guest" edge to the User entity.
func (m *EventMutation) RemovedGuestIDs() (ids []int) {
	for id := range m.removedguest {
		ids = append(ids, id)
	}
	return
}

// GuestIDs returns the "guest" edge IDs in the mutation.
func (m *EventMutation) GuestIDs() (ids []int) {
	for id := range m.guest {
		ids = append(ids, id)
	}
	return
}

// ResetGuest resets all changes to the "guest" edge.
func (m *EventMutation) ResetGuest() {
	m.guest = nil
	m.clearedguest = false
	m.removedguest = nil
}

// AddTicketIDs adds the "ticket" edge to the Ticket entity by ids.
func (m *EventMutation) AddTicketIDs(ids ...int) {
	if m.ticket == nil {
		m.ticket = make(map[int]struct{})
	}
	for i := range ids {
		m.ticket[ids[i]] = struct{}{}
	}
}

// ClearTicket clears the "ticket" edge to the Ticket entity.
func (m *EventMutation) ClearTicket() {
	m.clearedticket = true
}

// TicketCleared reports if the "ticket" edge to the Ticket entity was cleared.
func (m *EventMutation) TicketCleared() bool {
	return m.clearedticket
}

// RemoveTicketIDs removes the "ticket" edge to the Ticket entity by IDs.
func (m *EventMutation) RemoveTicketIDs(ids ...int) {
	if m.removedticket == nil {
		m.removedticket = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ticket, ids[i])
		m.removedticket[ids[i]] = struct{}{}
	}
}

// RemovedTicket returns the removed IDs of the "ticket" edge to the Ticket entity.
func (m *EventMutation) RemovedTicketIDs() (ids []int) {
	for id := range m.removedticket {
		ids = append(ids, id)
	}
	return
}

// TicketIDs returns the "ticket" edge IDs in the mutation.
func (m *EventMutation) TicketIDs() (ids []int) {
	for id := range m.ticket {
		ids = append(ids, id)
	}
	return
}

// ResetTicket resets all changes to the "ticket" edge.
func (m *EventMutation) ResetTicket() {
	m.ticket = nil
	m.clearedticket = false
	m.removedticket = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.create_time != nil {
		fields = append(fields, event.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, event.FieldUpdateTime)
	}
	if m.uuid != nil {
		fields = append(fields, event.FieldUUID)
	}
	if m.title != nil {
		fields = append(fields, event.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.start_date != nil {
		fields = append(fields, event.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, event.FieldEndDate)
	}
	if m.event_type != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.status != nil {
		fields = append(fields, event.FieldStatus)
	}
	if m.is_public != nil {
		fields = append(fields, event.FieldIsPublic)
	}
	if m.is_paid != nil {
		fields = append(fields, event.FieldIsPaid)
	}
	if m.max_participants != nil {
		fields = append(fields, event.FieldMaxParticipants)
	}
	if m.registration_deadline != nil {
		fields = append(fields, event.FieldRegistrationDeadline)
	}
	if m.cover_photo_id != nil {
		fields = append(fields, event.FieldCoverPhotoID)
	}
	if m.user != nil {
		fields = append(fields, event.FieldOrganizerID)
	}
	if m.location != nil {
		fields = append(fields, event.FieldLocationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreateTime:
		return m.CreateTime()
	case event.FieldUpdateTime:
		return m.UpdateTime()
	case event.FieldUUID:
		return m.UUID()
	case event.FieldTitle:
		return m.Title()
	case event.FieldDescription:
		return m.Description()
	case event.FieldStartDate:
		return m.StartDate()
	case event.FieldEndDate:
		return m.EndDate()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldStatus:
		return m.Status()
	case event.FieldIsPublic:
		return m.IsPublic()
	case event.FieldIsPaid:
		return m.IsPaid()
	case event.FieldMaxParticipants:
		return m.MaxParticipants()
	case event.FieldRegistrationDeadline:
		return m.RegistrationDeadline()
	case event.FieldCoverPhotoID:
		return m.CoverPhotoID()
	case event.FieldOrganizerID:
		return m.OrganizerID()
	case event.FieldLocationID:
		return m.LocationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case event.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case event.FieldUUID:
		return m.OldUUID(ctx)
	case event.FieldTitle:
		return m.OldTitle(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldStartDate:
		return m.OldStartDate(ctx)
	case event.FieldEndDate:
		return m.OldEndDate(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldStatus:
		return m.OldStatus(ctx)
	case event.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case event.FieldIsPaid:
		return m.OldIsPaid(ctx)
	case event.FieldMaxParticipants:
		return m.OldMaxParticipants(ctx)
	case event.FieldRegistrationDeadline:
		return m.OldRegistrationDeadline(ctx)
	case event.FieldCoverPhotoID:
		return m.OldCoverPhotoID(ctx)
	case event.FieldOrganizerID:
		return m.OldOrganizerID(ctx)
	case event.FieldLocationID:
		return m.OldLocationID(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case event.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case event.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case event.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case event.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldStatus:
		v, ok := value.(event.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case event.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case event.FieldIsPaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPaid(v)
		return nil
	case event.FieldMaxParticipants:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxParticipants(v)
		return nil
	case event.FieldRegistrationDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationDeadline(v)
		return nil
	case event.FieldCoverPhotoID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverPhotoID(v)
		return nil
	case event.FieldOrganizerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizerID(v)
		return nil
	case event.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addmax_participants != nil {
		fields = append(fields, event.FieldMaxParticipants)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldMaxParticipants:
		return m.AddedMaxParticipants()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldMaxParticipants:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxParticipants(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldRegistrationDeadline) {
		fields = append(fields, event.FieldRegistrationDeadline)
	}
	if m.FieldCleared(event.FieldCoverPhotoID) {
		fields = append(fields, event.FieldCoverPhotoID)
	}
	if m.FieldCleared(event.FieldLocationID) {
		fields = append(fields, event.FieldLocationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldRegistrationDeadline:
		m.ClearRegistrationDeadline()
		return nil
	case event.FieldCoverPhotoID:
		m.ClearCoverPhotoID()
		return nil
	case event.FieldLocationID:
		m.ClearLocationID()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case event.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case event.FieldUUID:
		m.ResetUUID()
		return nil
	case event.FieldTitle:
		m.ResetTitle()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldStartDate:
		m.ResetStartDate()
		return nil
	case event.FieldEndDate:
		m.ResetEndDate()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldStatus:
		m.ResetStatus()
		return nil
	case event.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case event.FieldIsPaid:
		m.ResetIsPaid()
		return nil
	case event.FieldMaxParticipants:
		m.ResetMaxParticipants()
		return nil
	case event.FieldRegistrationDeadline:
		m.ResetRegistrationDeadline()
		return nil
	case event.FieldCoverPhotoID:
		m.ResetCoverPhotoID()
		return nil
	case event.FieldOrganizerID:
		m.ResetOrganizerID()
		return nil
	case event.FieldLocationID:
		m.ResetLocationID()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, event.EdgeUser)
	}
	if m.location != nil {
		edges = append(edges, event.EdgeLocation)
	}
	if m.guest != nil {
		edges = append(edges, event.EdgeGuest)
	}
	if m.ticket != nil {
		edges = append(edges, event.EdgeTicket)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeGuest:
		ids := make([]ent.Value, 0, len(m.guest))
		for id := range m.guest {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeTicket:
		ids := make([]ent.Value, 0, len(m.ticket))
		for id := range m.ticket {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedguest != nil {
		edges = append(edges, event.EdgeGuest)
	}
	if m.removedticket != nil {
		edges = append(edges, event.EdgeTicket)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeGuest:
		ids := make([]ent.Value, 0, len(m.removedguest))
		for id := range m.removedguest {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeTicket:
		ids := make([]ent.Value, 0, len(m.removedticket))
		for id := range m.removedticket {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, event.EdgeUser)
	}
	if m.clearedlocation {
		edges = append(edges, event.EdgeLocation)
	}
	if m.clearedguest {
		edges = append(edges, event.EdgeGuest)
	}
	if m.clearedticket {
		edges = append(edges, event.EdgeTicket)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeUser:
		return m.cleareduser
	case event.EdgeLocation:
		return m.clearedlocation
	case event.EdgeGuest:
		return m.clearedguest
	case event.EdgeTicket:
		return m.clearedticket
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeUser:
		m.ClearUser()
		return nil
	case event.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeUser:
		m.ResetUser()
		return nil
	case event.EdgeLocation:
		m.ResetLocation()
		return nil
	case event.EdgeGuest:
		m.ResetGuest()
		return nil
	case event.EdgeTicket:
		m.ResetTicket()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	uuid          *uuid.UUID
	name          *string
	address       *string
	city          *string
	state         *string
	country       *string
	postal_code   *string
	latitude      *float64
	addlatitude   *float64
	longitude     *float64
	addlongitude  *float64
	capacity      *int
	addcapacity   *int
	clearedFields map[string]struct{}
	event         map[int]struct{}
	removedevent  map[int]struct{}
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*Location, error)
	predicates    []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *LocationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LocationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LocationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *LocationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LocationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LocationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUUID sets the "uuid" field.
func (m *LocationMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *LocationMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *LocationMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *LocationMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LocationMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *LocationMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[location.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *LocationMutation) AddressCleared() bool {
	_, ok := m.clearedFields[location.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *LocationMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, location.FieldAddress)
}

// SetCity sets the "city" field.
func (m *LocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *LocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *LocationMutation) ClearCity() {
	m.city = nil
	m.clearedFields[location.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *LocationMutation) CityCleared() bool {
	_, ok := m.clearedFields[location.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *LocationMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, location.FieldCity)
}

// SetState sets the "state" field.
func (m *LocationMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *LocationMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *LocationMutation) ClearState() {
	m.state = nil
	m.clearedFields[location.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *LocationMutation) StateCleared() bool {
	_, ok := m.clearedFields[location.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *LocationMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, location.FieldState)
}

// SetCountry sets the "country" field.
func (m *LocationMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *LocationMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *LocationMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[location.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *LocationMutation) CountryCleared() bool {
	_, ok := m.clearedFields[location.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *LocationMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, location.FieldCountry)
}

// SetPostalCode sets the "postal_code" field.
func (m *LocationMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *LocationMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *LocationMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[location.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *LocationMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[location.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *LocationMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, location.FieldPostalCode)
}

// SetLatitude sets the "latitude" field.
func (m *LocationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LocationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LocationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LocationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *LocationMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[location.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *LocationMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LocationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, location.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *LocationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LocationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LocationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LocationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *LocationMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[location.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *LocationMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LocationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, location.FieldLongitude)
}

// SetCapacity sets the "capacity" field.
func (m *LocationMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *LocationMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *LocationMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *LocationMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCapacity clears the value of the "capacity" field.
func (m *LocationMutation) ClearCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	m.clearedFields[location.FieldCapacity] = struct{}{}
}

// CapacityCleared returns if the "capacity" field was cleared in this mutation.
func (m *LocationMutation) CapacityCleared() bool {
	_, ok := m.clearedFields[location.FieldCapacity]
	return ok
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *LocationMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
	delete(m.clearedFields, location.FieldCapacity)
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *LocationMutation) AddEventIDs(ids ...int) {
	if m.event == nil {
		m.event = make(map[int]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *LocationMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *LocationMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *LocationMutation) RemoveEventIDs(ids ...int) {
	if m.removedevent == nil {
		m.removedevent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *LocationMutation) RemovedEventIDs() (ids []int) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *LocationMutation) EventIDs() (ids []int) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *LocationMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, location.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, location.FieldUpdateTime)
	}
	if m.uuid != nil {
		fields = append(fields, location.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.address != nil {
		fields = append(fields, location.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, location.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, location.FieldState)
	}
	if m.country != nil {
		fields = append(fields, location.FieldCountry)
	}
	if m.postal_code != nil {
		fields = append(fields, location.FieldPostalCode)
	}
	if m.latitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.capacity != nil {
		fields = append(fields, location.FieldCapacity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldCreateTime:
		return m.CreateTime()
	case location.FieldUpdateTime:
		return m.UpdateTime()
	case location.FieldUUID:
		return m.UUID()
	case location.FieldName:
		return m.Name()
	case location.FieldAddress:
		return m.Address()
	case location.FieldCity:
		return m.City()
	case location.FieldState:
		return m.State()
	case location.FieldCountry:
		return m.Country()
	case location.FieldPostalCode:
		return m.PostalCode()
	case location.FieldLatitude:
		return m.Latitude()
	case location.FieldLongitude:
		return m.Longitude()
	case location.FieldCapacity:
		return m.Capacity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case location.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case location.FieldUUID:
		return m.OldUUID(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldAddress:
		return m.OldAddress(ctx)
	case location.FieldCity:
		return m.OldCity(ctx)
	case location.FieldState:
		return m.OldState(ctx)
	case location.FieldCountry:
		return m.OldCountry(ctx)
	case location.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case location.FieldLatitude:
		return m.OldLatitude(ctx)
	case location.FieldLongitude:
		return m.OldLongitude(ctx)
	case location.FieldCapacity:
		return m.OldCapacity(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case location.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case location.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case location.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case location.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case location.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case location.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case location.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.addcapacity != nil {
		fields = append(fields, location.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLatitude:
		return m.AddedLatitude()
	case location.FieldLongitude:
		return m.AddedLongitude()
	case location.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case location.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldAddress) {
		fields = append(fields, location.FieldAddress)
	}
	if m.FieldCleared(location.FieldCity) {
		fields = append(fields, location.FieldCity)
	}
	if m.FieldCleared(location.FieldState) {
		fields = append(fields, location.FieldState)
	}
	if m.FieldCleared(location.FieldCountry) {
		fields = append(fields, location.FieldCountry)
	}
	if m.FieldCleared(location.FieldPostalCode) {
		fields = append(fields, location.FieldPostalCode)
	}
	if m.FieldCleared(location.FieldLatitude) {
		fields = append(fields, location.FieldLatitude)
	}
	if m.FieldCleared(location.FieldLongitude) {
		fields = append(fields, location.FieldLongitude)
	}
	if m.FieldCleared(location.FieldCapacity) {
		fields = append(fields, location.FieldCapacity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldAddress:
		m.ClearAddress()
		return nil
	case location.FieldCity:
		m.ClearCity()
		return nil
	case location.FieldState:
		m.ClearState()
		return nil
	case location.FieldCountry:
		m.ClearCountry()
		return nil
	case location.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case location.FieldLatitude:
		m.ClearLatitude()
		return nil
	case location.FieldLongitude:
		m.ClearLongitude()
		return nil
	case location.FieldCapacity:
		m.ClearCapacity()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case location.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case location.FieldUUID:
		m.ResetUUID()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldAddress:
		m.ResetAddress()
		return nil
	case location.FieldCity:
		m.ResetCity()
		return nil
	case location.FieldState:
		m.ResetState()
		return nil
	case location.FieldCountry:
		m.ResetCountry()
		return nil
	case location.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case location.FieldLatitude:
		m.ResetLatitude()
		return nil
	case location.FieldLongitude:
		m.ResetLongitude()
		return nil
	case location.FieldCapacity:
		m.ResetCapacity()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, location.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevent != nil {
		edges = append(edges, location.EdgeEvent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, location.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	uuid             *uuid.UUID
	name             *string
	description      *string
	price            *float64
	addprice         *float64
	quantity         *int
	addquantity      *int
	quantity_sold    *int
	addquantity_sold *int
	sale_start_date  *time.Time
	sale_end_date    *time.Time
	event_id         *string
	ticket_type      *string
	is_active        *bool
	is_refundable    *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Ticket, error)
	predicates       []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id int) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TicketMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TicketMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TicketMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TicketMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TicketMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TicketMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUUID sets the "uuid" field.
func (m *TicketMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TicketMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TicketMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *TicketMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TicketMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TicketMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TicketMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TicketMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TicketMutation) ResetDescription() {
	m.description = nil
}

// SetPrice sets the "price" field.
func (m *TicketMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *TicketMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *TicketMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *TicketMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *TicketMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetQuantity sets the "quantity" field.
func (m *TicketMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *TicketMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *TicketMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *TicketMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *TicketMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetQuantitySold sets the "quantity_sold" field.
func (m *TicketMutation) SetQuantitySold(i int) {
	m.quantity_sold = &i
	m.addquantity_sold = nil
}

// QuantitySold returns the value of the "quantity_sold" field in the mutation.
func (m *TicketMutation) QuantitySold() (r int, exists bool) {
	v := m.quantity_sold
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantitySold returns the old "quantity_sold" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldQuantitySold(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantitySold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantitySold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantitySold: %w", err)
	}
	return oldValue.QuantitySold, nil
}

// AddQuantitySold adds i to the "quantity_sold" field.
func (m *TicketMutation) AddQuantitySold(i int) {
	if m.addquantity_sold != nil {
		*m.addquantity_sold += i
	} else {
		m.addquantity_sold = &i
	}
}

// AddedQuantitySold returns the value that was added to the "quantity_sold" field in this mutation.
func (m *TicketMutation) AddedQuantitySold() (r int, exists bool) {
	v := m.addquantity_sold
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantitySold resets all changes to the "quantity_sold" field.
func (m *TicketMutation) ResetQuantitySold() {
	m.quantity_sold = nil
	m.addquantity_sold = nil
}

// SetSaleStartDate sets the "sale_start_date" field.
func (m *TicketMutation) SetSaleStartDate(t time.Time) {
	m.sale_start_date = &t
}

// SaleStartDate returns the value of the "sale_start_date" field in the mutation.
func (m *TicketMutation) SaleStartDate() (r time.Time, exists bool) {
	v := m.sale_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleStartDate returns the old "sale_start_date" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSaleStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleStartDate: %w", err)
	}
	return oldValue.SaleStartDate, nil
}

// ResetSaleStartDate resets all changes to the "sale_start_date" field.
func (m *TicketMutation) ResetSaleStartDate() {
	m.sale_start_date = nil
}

// SetSaleEndDate sets the "sale_end_date" field.
func (m *TicketMutation) SetSaleEndDate(t time.Time) {
	m.sale_end_date = &t
}

// SaleEndDate returns the value of the "sale_end_date" field in the mutation.
func (m *TicketMutation) SaleEndDate() (r time.Time, exists bool) {
	v := m.sale_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleEndDate returns the old "sale_end_date" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSaleEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleEndDate: %w", err)
	}
	return oldValue.SaleEndDate, nil
}

// ClearSaleEndDate clears the value of the "sale_end_date" field.
func (m *TicketMutation) ClearSaleEndDate() {
	m.sale_end_date = nil
	m.clearedFields[ticket.FieldSaleEndDate] = struct{}{}
}

// SaleEndDateCleared returns if the "sale_end_date" field was cleared in this mutation.
func (m *TicketMutation) SaleEndDateCleared() bool {
	_, ok := m.clearedFields[ticket.FieldSaleEndDate]
	return ok
}

// ResetSaleEndDate resets all changes to the "sale_end_date" field.
func (m *TicketMutation) ResetSaleEndDate() {
	m.sale_end_date = nil
	delete(m.clearedFields, ticket.FieldSaleEndDate)
}

// SetEventID sets the "event_id" field.
func (m *TicketMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *TicketMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *TicketMutation) ResetEventID() {
	m.event_id = nil
}

// SetTicketType sets the "ticket_type" field.
func (m *TicketMutation) SetTicketType(s string) {
	m.ticket_type = &s
}

// TicketType returns the value of the "ticket_type" field in the mutation.
func (m *TicketMutation) TicketType() (r string, exists bool) {
	v := m.ticket_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTicketType returns the old "ticket_type" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldTicketType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTicketType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTicketType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTicketType: %w", err)
	}
	return oldValue.TicketType, nil
}

// ResetTicketType resets all changes to the "ticket_type" field.
func (m *TicketMutation) ResetTicketType() {
	m.ticket_type = nil
}

// SetIsActive sets the "is_active" field.
func (m *TicketMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TicketMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TicketMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsRefundable sets the "is_refundable" field.
func (m *TicketMutation) SetIsRefundable(b bool) {
	m.is_refundable = &b
}

// IsRefundable returns the value of the "is_refundable" field in the mutation.
func (m *TicketMutation) IsRefundable() (r bool, exists bool) {
	v := m.is_refundable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRefundable returns the old "is_refundable" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldIsRefundable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRefundable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRefundable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRefundable: %w", err)
	}
	return oldValue.IsRefundable, nil
}

// ResetIsRefundable resets all changes to the "is_refundable" field.
func (m *TicketMutation) ResetIsRefundable() {
	m.is_refundable = nil
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, ticket.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ticket.FieldUpdateTime)
	}
	if m.uuid != nil {
		fields = append(fields, ticket.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, ticket.FieldName)
	}
	if m.description != nil {
		fields = append(fields, ticket.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, ticket.FieldPrice)
	}
	if m.quantity != nil {
		fields = append(fields, ticket.FieldQuantity)
	}
	if m.quantity_sold != nil {
		fields = append(fields, ticket.FieldQuantitySold)
	}
	if m.sale_start_date != nil {
		fields = append(fields, ticket.FieldSaleStartDate)
	}
	if m.sale_end_date != nil {
		fields = append(fields, ticket.FieldSaleEndDate)
	}
	if m.event_id != nil {
		fields = append(fields, ticket.FieldEventID)
	}
	if m.ticket_type != nil {
		fields = append(fields, ticket.FieldTicketType)
	}
	if m.is_active != nil {
		fields = append(fields, ticket.FieldIsActive)
	}
	if m.is_refundable != nil {
		fields = append(fields, ticket.FieldIsRefundable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldCreateTime:
		return m.CreateTime()
	case ticket.FieldUpdateTime:
		return m.UpdateTime()
	case ticket.FieldUUID:
		return m.UUID()
	case ticket.FieldName:
		return m.Name()
	case ticket.FieldDescription:
		return m.Description()
	case ticket.FieldPrice:
		return m.Price()
	case ticket.FieldQuantity:
		return m.Quantity()
	case ticket.FieldQuantitySold:
		return m.QuantitySold()
	case ticket.FieldSaleStartDate:
		return m.SaleStartDate()
	case ticket.FieldSaleEndDate:
		return m.SaleEndDate()
	case ticket.FieldEventID:
		return m.EventID()
	case ticket.FieldTicketType:
		return m.TicketType()
	case ticket.FieldIsActive:
		return m.IsActive()
	case ticket.FieldIsRefundable:
		return m.IsRefundable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ticket.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ticket.FieldUUID:
		return m.OldUUID(ctx)
	case ticket.FieldName:
		return m.OldName(ctx)
	case ticket.FieldDescription:
		return m.OldDescription(ctx)
	case ticket.FieldPrice:
		return m.OldPrice(ctx)
	case ticket.FieldQuantity:
		return m.OldQuantity(ctx)
	case ticket.FieldQuantitySold:
		return m.OldQuantitySold(ctx)
	case ticket.FieldSaleStartDate:
		return m.OldSaleStartDate(ctx)
	case ticket.FieldSaleEndDate:
		return m.OldSaleEndDate(ctx)
	case ticket.FieldEventID:
		return m.OldEventID(ctx)
	case ticket.FieldTicketType:
		return m.OldTicketType(ctx)
	case ticket.FieldIsActive:
		return m.OldIsActive(ctx)
	case ticket.FieldIsRefundable:
		return m.OldIsRefundable(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ticket.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ticket.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case ticket.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ticket.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ticket.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case ticket.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case ticket.FieldQuantitySold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantitySold(v)
		return nil
	case ticket.FieldSaleStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleStartDate(v)
		return nil
	case ticket.FieldSaleEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleEndDate(v)
		return nil
	case ticket.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case ticket.FieldTicketType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTicketType(v)
		return nil
	case ticket.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case ticket.FieldIsRefundable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRefundable(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, ticket.FieldPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, ticket.FieldQuantity)
	}
	if m.addquantity_sold != nil {
		fields = append(fields, ticket.FieldQuantitySold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldPrice:
		return m.AddedPrice()
	case ticket.FieldQuantity:
		return m.AddedQuantity()
	case ticket.FieldQuantitySold:
		return m.AddedQuantitySold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case ticket.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case ticket.FieldQuantitySold:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantitySold(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldSaleEndDate) {
		fields = append(fields, ticket.FieldSaleEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldSaleEndDate:
		m.ClearSaleEndDate()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ticket.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ticket.FieldUUID:
		m.ResetUUID()
		return nil
	case ticket.FieldName:
		m.ResetName()
		return nil
	case ticket.FieldDescription:
		m.ResetDescription()
		return nil
	case ticket.FieldPrice:
		m.ResetPrice()
		return nil
	case ticket.FieldQuantity:
		m.ResetQuantity()
		return nil
	case ticket.FieldQuantitySold:
		m.ResetQuantitySold()
		return nil
	case ticket.FieldSaleStartDate:
		m.ResetSaleStartDate()
		return nil
	case ticket.FieldSaleEndDate:
		m.ResetSaleEndDate()
		return nil
	case ticket.FieldEventID:
		m.ResetEventID()
		return nil
	case ticket.FieldTicketType:
		m.ResetTicketType()
		return nil
	case ticket.FieldIsActive:
		m.ResetIsActive()
		return nil
	case ticket.FieldIsRefundable:
		m.ResetIsRefundable()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ticket edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	uuid              *uuid.UUID
	first_name        *string
	last_name         *string
	email             *string
	password          *string
	phone             *string
	is_vendor         *bool
	email_verified    *bool
	phone_verified    *bool
	email_verified_at *time.Time
	phone_verified_at *time.Time
	disabled          *bool
	clearedFields     map[string]struct{}
	event             map[int]struct{}
	removedevent      map[int]struct{}
	clearedevent      bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetIsVendor sets the "is_vendor" field.
func (m *UserMutation) SetIsVendor(b bool) {
	m.is_vendor = &b
}

// IsVendor returns the value of the "is_vendor" field in the mutation.
func (m *UserMutation) IsVendor() (r bool, exists bool) {
	v := m.is_vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVendor returns the old "is_vendor" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsVendor(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVendor: %w", err)
	}
	return oldValue.IsVendor, nil
}

// ResetIsVendor resets all changes to the "is_vendor" field.
func (m *UserMutation) ResetIsVendor() {
	m.is_vendor = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetPhoneVerified sets the "phone_verified" field.
func (m *UserMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the value of the "phone_verified" field in the mutation.
func (m *UserMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old "phone_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ResetPhoneVerified resets all changes to the "phone_verified" field.
func (m *UserMutation) ResetPhoneVerified() {
	m.phone_verified = nil
}

// SetEmailVerifiedAt sets the "email_verified_at" field.
func (m *UserMutation) SetEmailVerifiedAt(t time.Time) {
	m.email_verified_at = &t
}

// EmailVerifiedAt returns the value of the "email_verified_at" field in the mutation.
func (m *UserMutation) EmailVerifiedAt() (r time.Time, exists bool) {
	v := m.email_verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerifiedAt returns the old "email_verified_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerifiedAt: %w", err)
	}
	return oldValue.EmailVerifiedAt, nil
}

// ClearEmailVerifiedAt clears the value of the "email_verified_at" field.
func (m *UserMutation) ClearEmailVerifiedAt() {
	m.email_verified_at = nil
	m.clearedFields[user.FieldEmailVerifiedAt] = struct{}{}
}

// EmailVerifiedAtCleared returns if the "email_verified_at" field was cleared in this mutation.
func (m *UserMutation) EmailVerifiedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailVerifiedAt]
	return ok
}

// ResetEmailVerifiedAt resets all changes to the "email_verified_at" field.
func (m *UserMutation) ResetEmailVerifiedAt() {
	m.email_verified_at = nil
	delete(m.clearedFields, user.FieldEmailVerifiedAt)
}

// SetPhoneVerifiedAt sets the "phone_verified_at" field.
func (m *UserMutation) SetPhoneVerifiedAt(t time.Time) {
	m.phone_verified_at = &t
}

// PhoneVerifiedAt returns the value of the "phone_verified_at" field in the mutation.
func (m *UserMutation) PhoneVerifiedAt() (r time.Time, exists bool) {
	v := m.phone_verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerifiedAt returns the old "phone_verified_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerifiedAt: %w", err)
	}
	return oldValue.PhoneVerifiedAt, nil
}

// ClearPhoneVerifiedAt clears the value of the "phone_verified_at" field.
func (m *UserMutation) ClearPhoneVerifiedAt() {
	m.phone_verified_at = nil
	m.clearedFields[user.FieldPhoneVerifiedAt] = struct{}{}
}

// PhoneVerifiedAtCleared returns if the "phone_verified_at" field was cleared in this mutation.
func (m *UserMutation) PhoneVerifiedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneVerifiedAt]
	return ok
}

// ResetPhoneVerifiedAt resets all changes to the "phone_verified_at" field.
func (m *UserMutation) ResetPhoneVerifiedAt() {
	m.phone_verified_at = nil
	delete(m.clearedFields, user.FieldPhoneVerifiedAt)
}

// SetDisabled sets the "disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *UserMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[user.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *UserMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[user.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *UserMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, user.FieldDisabled)
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *UserMutation) AddEventIDs(ids ...int) {
	if m.event == nil {
		m.event = make(map[int]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *UserMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *UserMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *UserMutation) RemoveEventIDs(ids ...int) {
	if m.removedevent == nil {
		m.removedevent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *UserMutation) RemovedEventIDs() (ids []int) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *UserMutation) EventIDs() (ids []int) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *UserMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.is_vendor != nil {
		fields = append(fields, user.FieldIsVendor)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.phone_verified != nil {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.email_verified_at != nil {
		fields = append(fields, user.FieldEmailVerifiedAt)
	}
	if m.phone_verified_at != nil {
		fields = append(fields, user.FieldPhoneVerifiedAt)
	}
	if m.disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUUID:
		return m.UUID()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldIsVendor:
		return m.IsVendor()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldPhoneVerified:
		return m.PhoneVerified()
	case user.FieldEmailVerifiedAt:
		return m.EmailVerifiedAt()
	case user.FieldPhoneVerifiedAt:
		return m.PhoneVerifiedAt()
	case user.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldIsVendor:
		return m.OldIsVendor(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case user.FieldEmailVerifiedAt:
		return m.OldEmailVerifiedAt(ctx)
	case user.FieldPhoneVerifiedAt:
		return m.OldPhoneVerifiedAt(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldIsVendor:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVendor(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case user.FieldEmailVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerifiedAt(v)
		return nil
	case user.FieldPhoneVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerifiedAt(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldEmailVerifiedAt) {
		fields = append(fields, user.FieldEmailVerifiedAt)
	}
	if m.FieldCleared(user.FieldPhoneVerifiedAt) {
		fields = append(fields, user.FieldPhoneVerifiedAt)
	}
	if m.FieldCleared(user.FieldDisabled) {
		fields = append(fields, user.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldEmailVerifiedAt:
		m.ClearEmailVerifiedAt()
		return nil
	case user.FieldPhoneVerifiedAt:
		m.ClearPhoneVerifiedAt()
		return nil
	case user.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldIsVendor:
		m.ResetIsVendor()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case user.FieldEmailVerifiedAt:
		m.ResetEmailVerifiedAt()
		return nil
	case user.FieldPhoneVerifiedAt:
		m.ResetPhoneVerifiedAt()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, user.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevent != nil {
		edges = append(edges, user.EdgeEvent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, user.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
